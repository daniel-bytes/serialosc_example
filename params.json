{"name":"Serialosc example","tagline":"Example application for hooking up monome devices to a c++ application using serialosc and oscpack.","body":"# Serial OSC C++ Example\r\nGetting a monome device to communicate with a custom-written native C++ application or VST plugin is actually not as hard as it might sound.  This tutorial will expect a moderate level of C++ knowledge, as well as a basic understanding of [Open Sound Control (OSC)](http://opensoundcontrol.org/) and Monome's [serialosc](http://monome.org/docs/app:serialosc) service/daemon application.  The tutorial was written on Windows in Visual C++ 2012, but it should be easy to compile on any other major compiler / IDE (XCode, GCC, Clang, etc).  Please note that I'm using a lot of C++11 goodies, so make sure your compiler is up to date.\r\n\r\n## First Steps\r\nFirst things first, go browse the code in the [serialosc_example repository](https://github.com/daniel-bytes/serialosc_example).  [serialosc_example.cpp](https://github.com/daniel-bytes/serialosc_example/blob/master/serialosc_example/serialosc_example.cpp) houses our main function entry point, so we should start there.  First thing you will notice is a class called MonomeDemo, but let's skip over that and check out the actual main function.\r\n\r\n`int main(int argc, const char* argv[])\r\n{\r\n        std::string input;\r\n        SerialOsc osc(\"test\", 13000);\r\n        MonomeDemo device(&osc);\r\n\r\n        while (input != \"q\") {\r\n                std::cout << \"type 'q' to quit.\" << std::endl;\r\n                std::getline(std::cin, input);\r\n        }\r\n\r\n        osc.stop();\r\n\r\n        return 0;\r\n}`\r\n\r\nMost of the code here is actually just used to set up an infinite loop (until 'q' is entered).  The main parts of interest are\r\n`SerialOsc osc(\"test\", 13000);\r\nMonomeDemo device(&osc);`\r\n\r\nThe first line here sets up a new SerialOsc object, passing in \"test\" as the device prefix and 130000 as the starting default port.  If you peek into SerialOsc.h, you'll notice the constructor actually takes 3 arguments:\r\n`SerialOsc(std::string devicePrefix, int defaultPort, int maxPortsToScan = 1000);`\r\nwith the third argument being the maximum number of ports to try and use, defaulting to 1000.  This just means that if the default port you select is not available, the SerialOsc object will attempt to bind to the next maxPortsToScan ports until one works.\r\n\r\nThe next line creates our MonomeDemo object, and passes it a pointer to our SerialOsc object in the constructor.\r\n\r\n## MonomeDemo Class\r\nLet's take a look at our MonomeDemo class, which also lives in [serialosc_example.cpp](https://github.com/daniel-bytes/serialosc_example/blob/master/serialosc_example/serialosc_example.cpp).\r\n\r\n`class MonomeDemo\r\n        : public SerialOsc::Listener\r\n{\r\npublic:\r\n        MonomeDemo(SerialOsc *osc)\r\n                : osc(osc)\r\n        {\r\n                osc->start(this);\r\n        }\r\n\r\npublic:\r\n        virtual void deviceFound(const MonomeDevice * const device)\r\n        {\r\n                std::cout << \"Found device \" << device->id << \" (type \" << device->type << \").\" << std::endl;\r\n                osc->sendDeviceLedAllCommand(device, false);\r\n        }\r\n\r\n        virtual void deviceRemoved(const std::string &id)\r\n        {\r\n                std::cout << \"Device \" << id << \" removed.\" << std::endl;\r\n        }\r\n        \r\n        virtual void buttonPressMessageReceived(MonomeDevice *device, int x, int y, bool state)\r\n        {\r\n                std::cout << \"Button press from \" << device->id << \" received. Prefix = \" << device->prefix << \",  x = \" << x << \", y = \" << y << \", state = \" << state << std::endl;\r\n                osc->sendDeviceLedCommand(device, x, y, state);\r\n        }\r\n\r\nprivate:\r\n        SerialOsc *osc;\r\n};`\r\n\r\nThis class represents our application itself, which is using the underlying SerialOsc object pointer to communicate with serialosc and our Monome devices.  Notice that our class inherits from SerialOsc::Listener.  This is a callback class type, and is used for SerialOsc to communicate that some device-specific event has occurred.  In this example, that would include the deviceFound, deviceRemoved and buttonPressMessageReceived methods.  If you look in these methods, you will see that a MonomeDevice object pointer is passed to the callback method, so that the application code can know which device the event occurred for.\r\n\r\n## MonomeDevice Class\r\nNext we should look at our MonomeDevice class.  If you look at MonomeDevice.h, you will notice it's actually just a POD (Plain Old Data) struct.\r\n\r\n`struct MonomeDevice\r\n{\r\n\tstd::string id;\r\n\tstd::string type;\r\n\tstd::string prefix;\r\n\tint port;\r\n\tint width;\r\n\tint height;\r\n\tint rotation;\r\n};`\r\n\r\nThe values stored here values returned from serialosc when querying for device information, so we will dive into those soon.\r\n\r\n## SerialOsc Class\r\nOK, finally we are at the meat of our little demo, the SerialOsc class.  This is the class that actually communicates with the serialosc server and allow us to access our Monome devices.\r\n\r\nserialosc uses OSC to for all communications.  OSC is an application-level protocol typically built on top of UDP.  Think of UDP as TCP's simpler sibling.  UDP is a network protocol, and network programming requires us to use Berkley Sockets or WinSock libraries, which is an awful lot of work.  Luckily, there are few C and C++ OSC libraries we can use to make our lives simpler.  For this example (and all of my own personal C++ application projects) I chose to use [oscpack](http://www.rossbencina.com/code/oscpack), written by Ross Bencina and distributed under the MIT open source license.  If you look in the repository, you'll notice I included the oscpack source, under the oscpack folder.  \r\n\r\nIn order for us to start listening for incoming OSC messages, we need to create a new UdpListeningReceiveSocket object.  The main problem we have here is that this object will block our thread while it waits for incoming messages, so we need to start this guy on it's own thread.  Luckily for us, C++ finally has a platform-independent threading library, defined under the `<thread>` header.  To take advantage of this, we just add the header as well as a std::thread member variable to our class.  Then, we set this up in our start method.\r\n\r\n`void SerialOsc::start(Listener *listener)\r\n{\r\n        this->listener = listener;\r\n \r\n        if (listener == nullptr || listenSocket != nullptr) {\r\n                return;\r\n        }\r\n        \r\n        for (int i = 0; i < portsToScan; i++) {\r\n                int tempPort = listenPort + i;\r\n \r\n                try {\r\n                        listenSocket = new UdpListeningReceiveSocket(\r\n                                        IpEndpointName( IpEndpointName::ANY_ADDRESS, tempPort ),\r\n                                        this);\r\n \r\n                        listenPort = tempPort;\r\n                        std::cout << \"Binding to port \" << tempPort << \".\" << std::endl;\r\n                        break;\r\n                }\r\n                catch(std::runtime_error &ex) {\r\n                        // try next port\r\n                        listenSocket = nullptr;\r\n                        std::cerr << \"Failed to bind to port \" << tempPort << \". \" << ex.what() << std::endl;\r\n                }\r\n        }\r\n \r\n        if (listenSocket != nullptr) {\r\n                thread = std::thread(&SerialOsc::runThread, this);\r\n \r\n                sendDeviceQueryMessage();\r\n                sendDeviceNotifyMessage();\r\n        }\r\n}`\r\n\r\nThis method takes a SerialOsc::Listener object pointer as it's parameter, which you will remember is implemented by our MonomeDemo class in serialosc_example.cpp.  Our SerialOsc class can then use this pointer to call back into the main application code to notify it of any device events (NOTE: remember we are listening on another thread, so this callback will happen on that thread.  This example code is NOT thread safe by any means, and a proper GUI application will probably need to then post this device information into some sort of queue for the GUI thread to read from and handle).\r\n\r\nThe next bit of code is our port scanning, as mentioned earlier.  We basically just loop from zero to portsToScan, add our default listenPort and hope we can bind to that port (if we can't a std::runtime_error is thrown that we can catch).\r\n\r\nOne we have our socket, we initialize our thread object with our SerialOsc class' runThread method, which will automatically start a new thread and call the specified method.\r\n\r\n`thread = std::thread(&SerialOsc::runThread, this);`\r\n\r\nrunThread itself is pretty simple, it just calls Run on our socket.\r\n\r\n`if (listenSocket != nullptr) {\r\n    listenSocket->Run();\r\n}`\r\n\r\nOnce our thread is running, we send 2 commands to SerialOsc to begin our device discovery process.  These are sendDeviceQueryMessage() and sendDeviceNotifyMessage().\r\n\r\n## Sending commands to serialosc\r\nTo send messages to serialosc, we can use the oscpack class UdpTransmitSocket.  This class represents an outgoing UDP socket connection to some destination server.  To use the class, we need to create a byte array buffer, as well as an osc::OutboundPacketStream object.  OutboundPacketStream works like most C++ output stream objects, using the left shift operator to push data into the stream.\r\n\r\nOnce our stream is set up with our message address and data, we can call Send on our UdpTransmitSocket to send the message out to our server.\r\n\r\n## Receiving Device Commands From SerialOsc\r\nThe real meat of our SerialOsc class is the ProcessMessage method, which handles any incoming messages from SerialOsc.  Note that this method is BIG!  It would be much cleaner to break out the handling of each message type into a separate method (or even another class for message parsing) but I kept it simple here for the sake of readability.\r\n\r\nSince we called sendDeviceQueryMessage(), we are expecting serialosc to respond with a message '/serialosc/device' (note that sendDeviceNotifyMessage() will respond with '/serialosc/add' if a new device is added after, and the handling of this is near identical to that of '/serialosc/device').  In our message handler here, our first order of business is to extract the OSC data and see what we get back.  That is handled by code that looks like this:\r\n\r\n`std::string id = (iter++)->AsString();\r\nstd::string type = (iter++)->AsString();\r\nint port = (iter++)->AsInt32();`\r\n\r\nwhich gives us our device id, device type and the port serialosc assigned to the device.\r\n\r\nAfter that, we check our devices vector to see if we already have this device registered.  In this example we are storing the devices in a vector, but another design might store them in a map or hash table with the device id as a key.  \r\n\r\n## Lambda Functions\r\nTo search the vector, we use the std::find_if function, which lives in the `<algorithm>` header.  This function lets us pass in a custom function to filter out the device we are searching for by some criteria.  What's nice about C++11 is that we finally have something called lambda functions.  Lambda functions are inline unnamed functions that are perfect for things like find_if, since we can specify the search code function in the same place as the code doing the search.  In older versions of C++ we would have to create a new function somewhere else to handle this searching.  The search code in question looks like this:\r\n\r\n`auto deviceIterator = std::find_if(devices.begin(), devices.end(), [id] (const MonomeDevice* x) { return x->id == id; });`\r\n\r\nFirst, we are using the 'auto' keyword to tell the compiler \"hey, you figure out what the type is on the right of the equals sign\", which is a nice convenience since C++ STL types can be awfully ugly to type out.  Next part that might look strange is \r\n`[id] (const MonomeDevice* x) {`\r\n\r\nThis is where our inline lambda function is defined.  The brackets [] tells the compiler what variables to \"capture\", to be allowed to be used inside the function.  Here we tell it we only care about the id variable, which we want to capture by value (the default in C++).  We could also specify [=] to capture EVERYTHING by value, or [&] to capture everything by reference (by \"everything\", I mean all variables in scope, which are local variables and class members in this case).\r\n\r\n## Back to serialosc Message Parsing\r\nNow that we have our device iterator, we can see if we already know about this device, or if we should add it to our vector.  After that, we call into our listener pointer to notify our application that we found a new device.  After that, we send a few messages back to serialosc: sendDeviceInfoMessage(port), sendDevicePrefixMessage(port) and sendDevicePortMessage(port).  sendDeviceInfoMessage() sends a request to serialosc for additional device information, sendDevicePrefixMessage(port) sends a request to serialosc to update our device prefix to the one defined in our SerialOsc constructor, and sendDevicePortMessage(port) tells serialosc to please start sending device button/tilt/knob/etc messages to our listen port, listening on the thread we set up earlier.\r\n\r\nWhen we called sendDeviceInfoMessage(), we are now expecting a series of messages to come back from serialosc.  The first will be '/sys/id'.  In our handler for this message, we just extract the ID from the message and store it in our currentDeviceID member variable.  Next we will receive '/sys/size', '/sys/rotation' and '/sys/prefix' (which we are ignoring) messages.  We use the ID we stored in currentDeviceID to know which device these messages are meant for (personally I wish serialosc just included the device id in these messages, but that's not how it works so we have to make due with the currentDeviceID variable instead).\r\n\r\nAnother interesting message we are handling is '/serialosc/remove'.  We receive this message when we unplug a device (and '/serialosc/add' when we plug a new device in).  We can use this to update our devices vector.  Note that after an add or remove message is sent, we must immediately re-register our application with serialosc to receive more notifications by calling sendDeviceNotifyMessage().\r\n\r\nOur final message type we are looking at is our device button press messages.  Note the following else block:\r\n`else if (address == (\"/\" + devicePrefix + \"/grid/key\")) {`\r\nBecause serialosc will send device messages using the prefix we specified earlier, we need to look for messages using that prefix in the address pattern.  Note that we are doing a string concatenation here, for performance it would be better if calculated this string as soon as we know what the device prefix is.\r\n\r\n## Sending Device LED Commands\r\nThis should be pretty simple to understand now, just take a look at sendDeviceLedCommand() and sendDeviceLedAllCommand().\r\n\r\n## Final Thoughts\r\nThat basically concludes our tutorial, hopefully by now you can compile the code and play with the debugger to see how it all works.\r\n\r\nSome things that are missing from this example code that you might want to account for in real production code are:\r\n- Multiple prefixes per device\r\n- Thread-safe device message callbacks\r\n- Additional device LED commands \r\n- Additional device message types (tilt, arc, etc).","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}